// Code generated by "enumer --type=ContractMethod --linecomment --extramethod --output=contract_method_enum.go"; DO NOT EDIT.

package tron

import (
	"fmt"
	"strconv"
)

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[ContractMethod_Unknown-0]
	_ = x[ContractUSDTMethod_Transfer-1]
	_ = x[ContractUSDTMethod_Approve-2]
	_ = x[ContractUSDTMethod_DecreaseApproval-3]
	_ = x[ContractUSDTMethod_Unpause-4]
	_ = x[ContractUSDTMethod_Issue-5]
	_ = x[ContractUSDTMethod_AddBlackList-6]
	_ = x[ContractUSDTMethod_TransferOwnership-7]
	_ = x[ContractUSDTMethod_TransferFrom-8]
	_ = x[ContractUSDTMethod_RemoveBlackList-9]
	_ = x[ContractUSDTMethod_Deprecate-10]
	_ = x[ContractUSDTMethod_IncreaseApproval-11]
	_ = x[ContractUSDTMethod_Redeem-12]
	_ = x[ContractUSDTMethod_SetParams-13]
	_ = x[ContractUSDTMethod_DestroyBlackFunds-14]
	_ = x[ContractUSDTMethod_Pause-15]
}

const _ContractMethod_name = "UNKNOWNa9059cbb095ea7b3661884633f4ba83acc872b660ecb93c0f2fde38b23b872dde4997dc50753c30cd73dd623db006a75c0324c77f3bdc2288456cb59"

var _ContractMethod_index = [...]uint8{0, 7, 15, 23, 31, 39, 47, 55, 63, 71, 79, 87, 95, 103, 111, 119, 127}

func (i ContractMethod) String() string {
	if i >= ContractMethod(len(_ContractMethod_index)-1) {
		return "ContractMethod(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _ContractMethod_name[_ContractMethod_index[i]:_ContractMethod_index[i+1]]
}

var _ContractMethod_values = []ContractMethod{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}

var _ContractMethod_name_to_value_map = map[string]ContractMethod{
	_ContractMethod_name[0:7]:     0,
	_ContractMethod_name[7:15]:    1,
	_ContractMethod_name[15:23]:   2,
	_ContractMethod_name[23:31]:   3,
	_ContractMethod_name[31:39]:   4,
	_ContractMethod_name[39:47]:   5,
	_ContractMethod_name[47:55]:   6,
	_ContractMethod_name[55:63]:   7,
	_ContractMethod_name[63:71]:   8,
	_ContractMethod_name[71:79]:   9,
	_ContractMethod_name[79:87]:   10,
	_ContractMethod_name[87:95]:   11,
	_ContractMethod_name[95:103]:  12,
	_ContractMethod_name[103:111]: 13,
	_ContractMethod_name[111:119]: 14,
	_ContractMethod_name[119:127]: 15,
}

// ContractMethodFromStr 将字符串转换成 ContractMethod 枚举类型；如果传入的不是有效的枚举值，抛出错误。
func ContractMethodFromStr(s string) (ContractMethod, error) {
	if val, ok := _ContractMethod_name_to_value_map[s]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("not valid enum")
}

// ContractMethodFromInt 将int值转换成 ContractMethod 枚举类型；如果传入的不是有效的枚举值，抛出错误。
func ContractMethodFromInt(i int) (ContractMethod, error) {
	if _ContractMethodIsValid(i) {
		return ContractMethod(i), nil
	}
	return 0, fmt.Errorf("not valid enum")
}

// ContractMethodFromInt64 将int64转换成 ContractMethod 枚举类型；如果传入的不是有效的枚举值，抛出错误。
func ContractMethodFromInt64(i int64) (ContractMethod, error) {
	return ContractMethodFromInt(int(i))
}

// IsValid 判断该枚举值是否有效。
func (i ContractMethod) IsValid() bool {
	return _ContractMethodIsValid(int(i))
}

// Check 校验该枚举值是否有效，如果无效，抛出错误。
func (i ContractMethod) Check() (err error) {
	if is := i.IsValid(); !is {
		err = fmt.Errorf("not valid enum")
	}
	return err
}

type ContractMethodSlice []ContractMethod

// Has 判断给定枚举值是否在当前数组中。
func (inst ContractMethodSlice) Has(i ContractMethod) bool {
	for _, v := range inst {
		if i == v {
			return true
		}
	}
	return false
}

// Strings 将枚举数组转换为字符串数组。
func (inst ContractMethodSlice) Strings() []string {
	ss := make([]string, len(inst))
	for i, v := range inst {
		ss[i] = v.String()
	}
	return ss
}

// ContractMethodValues 返回 ContractMethod 类型的所有的枚举值。
func ContractMethodValues() ContractMethodSlice {
	return _ContractMethod_values
}

// ContractMethodFromStrs 将字符串数组转换成 ContractMethod 枚举数组；如果传入的字符串不是有效的枚举值，抛出错误。
func ContractMethodFromStrs(ss []string) (ContractMethodSlice, error) {
	es := make(ContractMethodSlice, 0, len(ss))
	for _, s := range ss {
		v, err := ContractMethodFromStr(s)
		if err != nil {
			return nil, err
		}
		es = append(es, v)
	}
	return es, nil
}

// ContractMethodFromInts 将int数组转换成 ContractMethod 枚举数组；如果传入的不是有效的枚举值，抛出错误。
func ContractMethodFromInts(ints []int) (ContractMethodSlice, error) {
	es := make(ContractMethodSlice, 0, len(ints))
	for _, i := range ints {
		v, err := ContractMethodFromInt(i)
		if err != nil {
			return nil, err
		}
		es = append(es, v)
	}
	return es, nil
}

// ContractMethodFromInt64s 将int64数组转换成 ContractMethod 枚举数组；如果传入的不是有效的枚举值，抛出错误。
func ContractMethodFromInt64s(int64s []int64) (ContractMethodSlice, error) {
	ints := make([]int, 0, len(int64s))
	for _, i := range int64s {
		ints = append(ints, int(i))
	}
	return ContractMethodFromInts(ints)
}

// _ContractMethodIsValid 判断 int 是否是有效的枚举值
func _ContractMethodIsValid(i int) bool {
	for _, v := range _ContractMethod_values {
		if i == int(v) {
			return true
		}
	}
	return false
}
